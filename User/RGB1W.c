/********************************** (C) COPYRIGHT *******************************
 * File Name          : RGB1W.c
 * Author             : WCH
 * Version            : V1.0.0
 * Date               : 2023/07/06
 * Description        : 1-wire example 1W-RGB, 1W-DS1820
 *********************************************************************************
 * Copyright (c) 2021 Nanjing Qinheng Microelectronics Co., Ltd.
 * Attention: This software (modified or not) and binary are used for
 * microcontroller manufactured by Nanjing Qinheng Microelectronics.
 *******************************************************************************/

const unsigned char PIOC_1W_CODE[] =
                {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x16,0x60,0x00,0x00,0x00,0x00,0x00,0x00,	/* .........`...... */
				 0x00,0x00,0x0A,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* ...p............ */
				 0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x1C,0x5E,0x1C,0x47,	/* ......0......^.G */
				 0x1C,0x5D,0x16,0x60,0x1C,0x47,0x1E,0x02,0x09,0x10,0x31,0xC1,0x3E,0xC2,0x34,0xC3,	/* .].`.G....1.>.4. */
				 0x2F,0x80,0x20,0x2F,0x41,0x38,0x87,0x2F,0x2F,0x38,0xFC,0x2F,0x93,0x38,0x00,0x00,	/* ....A8...8...8.. */
				 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x28,	/* ...............( */
				 0x8E,0x60,0x00,0x00,0x2C,0x71,0x8E,0x60,0x00,0x00,0x2C,0x71,0x8E,0x30,0x4B,0x24,	/* .`..,q.`..,q.0K$ */
				 0x28,0x22,0xE9,0x70,0x04,0x15,0x39,0x30,0x09,0x15,0x38,0x30,0x00,0x00,0x38,0x71,	/* (".p..90..80..8q */
				 0x8E,0x60,0x00,0x00,0x08,0x01,0x0B,0x40,0x0A,0x48,0x0C,0x01,0x06,0x28,0x0B,0x54,	/* .`.....@.H...(.T */
				 0x8E,0x60,0x09,0x02,0x04,0x10,0x20,0x24,0x00,0x00,0x0B,0x48,0x0B,0x70,0x01,0x5F,	/* .`.....$...H.p._ */
				 0x0B,0x40,0x08,0x70,0x0B,0x40,0x0A,0x70,0x0B,0x48,0x0B,0x70,0x01,0x5E,0x0B,0x40,	/* .@.p.@.p.H.p.^.@ */
				 0x08,0x70,0x0B,0x40,0x0A,0x70,0x0B,0x48,0x0B,0x70,0x01,0x5D,0x0B,0x40,0x08,0x70,	/* .p.@.p.H.p.].@.p */
				 0x0B,0x40,0x0A,0x70,0x0B,0x48,0x0B,0x70,0x01,0x5C,0x0B,0x40,0x08,0x70,0x0B,0x40,	/* .@.p.H.p.\.@.p.@ */
				 0x0A,0x70,0x0B,0x48,0x0B,0x70,0x01,0x5B,0x0B,0x40,0x08,0x70,0x0B,0x40,0x0A,0x70,	/* .p.H.p.[.@.p.@.p */
				 0x0B,0x48,0x0B,0x70,0x01,0x5A,0x0B,0x40,0x08,0x70,0x0B,0x40,0x0A,0x70,0x0B,0x48,	/* .H.p.Z.@.p.@.p.H */
				 0x0B,0x70,0x01,0x59,0x0B,0x40,0x08,0x70,0x0B,0x40,0x0A,0x70,0x0B,0x48,0x0B,0x70,	/* .p.Y.@.p.@.p.H.p */
				 0x01,0x58,0x0B,0x40,0x09,0x70,0x01,0x02,0x0B,0x40,0x0D,0x70,0x04,0x15,0x4D,0x30,	/* .X.@.p...@.p..M0 */
				 0x1E,0x28,0xEE,0x70,0xEE,0x70,0x04,0x00,0x0B,0x54,0x04,0x28,0x1D,0x10,0x1C,0x4F,	/* .(.p.p...T.(...O */
				 0x16,0x60,0x02,0x28,0x8E,0x60,0x00,0x00,0x08,0x01,0x0B,0x40,0x80,0x28,0x0C,0x10,	/* .`.(.`.....@.(.. */
				 0x20,0x02,0x21,0x0A,0x91,0x34,0x0A,0x48,0x09,0x47,0x3E,0x01,0x04,0x01,0x06,0x28,	/* ..!..4.H.G>....( */
				 0x0B,0x54,0x8E,0x60,0x02,0x28,0x3F,0x10,0x18,0x00,0x1F,0x10,0x80,0x29,0x09,0x0A,	/* .T.`.(?......).. */
				 0x00,0x00,0x08,0x10,0x13,0x00,0xAE,0x00,0x13,0x00,0xAD,0x00,0x13,0x00,0xAC,0x00,	/* ................ */
				 0x13,0x00,0xAB,0x00,0x13,0x00,0xAA,0x00,0x13,0x00,0x20,0x15,0x20,0x04,0x03,0x52,	/* ...............R */
				 0x21,0x15,0xA9,0x00,0x13,0x00,0x20,0x02,0x21,0x0A,0xE3,0x34,0xA8,0x00,0x13,0x00,	/* !.......!..4.... */
				 0x04,0x02,0x1F,0x10,0xAF,0x00,0x13,0x00,0xAE,0x00,0x13,0x00,0xAD,0x00,0x13,0x00,	/* ................ */
				 0xAC,0x00,0x13,0x00,0x20,0x15,0x20,0x04,0x03,0x52,0x21,0x15,0xAB,0x00,0x13,0x00,	/* .........R!..... */
				 0x3E,0x14,0x03,0x52,0x3F,0x14,0xAA,0x00,0x13,0x00,0x3E,0x02,0x04,0x10,0xA9,0x00,	/* >..R?.....>..... */
				 0x13,0x00,0x20,0x02,0x21,0x0A,0xE3,0x34,0x3F,0x02,0xA8,0x00,0x13,0x00,0x18,0x00,	/* ....!..4?....... */
				 0x1F,0x10,0xAF,0x00,0xAA,0x60,0xA8,0x00,0x13,0x00,0x08,0x47,0x12,0x00,0x08,0x01,	/* .....`.....G.... */
				 0x88,0x60,0xFA,0x28,0xEE,0x60,0x41,0x28,0xEE,0x60,0x02,0x28,0x0D,0x70,0x00,0x00,	/* .`.(.`A(.`.(.p.. */
				 0x0D,0x70,0x00,0x00,0x0D,0x70,0x00,0x00,0x0D,0x70,0x00,0x00,0xFF,0x2C,0x00,0x00,	/* .p...p...p...,.. */
				 0xEE,0x30,0x30,0x00,0x0A,0x40,0x08,0x01,0x0C,0x01,0x05,0x28,0xEE,0x70,0x0B,0x40,	/* .00..@.....(.p.@ */
				 0x0A,0x48,0xE9,0x70,0xE9,0x70,0x0A,0x40,0xEB,0x70,0x09,0x01,0x0B,0x54,0x04,0x24,	/* .H.p.p.@.p...T.$ */
				 0xE9,0x70,0x09,0x02,0x30,0x00,0x09,0x10,0x08,0x22,0x0B,0x40,0x0A,0x48,0xED,0x70,	/* .p..0....".@.H.p */
				 0x09,0x50,0x0A,0x40,0xEB,0x70,0x0A,0x40,0x05,0x28,0x09,0x58,0xEE,0x70,0x09,0x1F,	/* .P.@.p.@.(.X.p.. */
				 0x04,0x15,0x0D,0x31,0x30,0x00,0x08,0x22,0x0B,0x40,0x0A,0x48,0xED,0x70,0x0A,0x40,	/* ...10..".@.H.p.@ */
				 0x0A,0x28,0xEE,0x70,0x09,0x1F,0x09,0x47,0x0B,0x54,0x09,0x4F,0x37,0x28,0xEE,0x70,	/* .(.p...G.T.O7(.p */
				 0x04,0x15,0x1C,0x31,0x09,0x02,0x30,0x00,0xFA,0x70,0x37,0x31,0xCC,0x28,0x0B,0x71,	/* ...1..0..p71.(.q */
				 0x44,0x28,0x0B,0x71,0x1C,0x5C,0x36,0x61,0x0B,0x48,0x0A,0x48,0x04,0x00,0x30,0x00,	/* D(.q.\6a.H.H..0. */
				 0xFA,0x70,0x43,0x31,0xCC,0x28,0x0B,0x71,0xBE,0x28,0x0B,0x71,0x1B,0x71,0x20,0x10,	/* .pC1.(.q.(.q.q.. */
				 0x1B,0x71,0x21,0x10,0xFA,0x70,0x30,0x00,0x00,0x00};	/* .q!..p0... */

#include "RGB1W.h"
#include <string.h>

__IO	uint8_t		stat;

void PIOC_IRQHandler(void) __attribute__((interrupt("WCH-Interrupt-fast")));

/*********************************************************************
 * @fn      PIOC_IRQHandler
 *
 * @brief   This function handles PIOC exception.
 *
 * @return  none
 */
void PIOC_IRQHandler( void )
{
//	uint8_t	stat;
	stat = PIOC->D8_CTRL_RD;//auto remove interrupt request after reading
//	if ( stat == RGB1W_ERR_OK ) printf("1-wire finished\r\n");
//	else printf("1-wire error %02x\r\n", stat);
//	temper = PIOC->D16_DATA_REG0_1;//for DS1820 only
}

/*********************************************************************
 * @fn      RGB1W_Init
 *
 * @brief   Init RGB1W.
 *
 * @return  none
 */
void RGB1W_Init ( void ) {
    GPIO_InitTypeDef GPIO_InitStructure = {0};

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOC, ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_IO2W, ENABLE);

#if 0  //PC18
    GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);
    GPIO_SetBits(GPIOC, GPIO_Pin_18);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_18;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOC, &GPIO_InitStructure);

#else  //PC7
    GPIO_PinRemapConfig(GPIO_Remap_PIOC, ENABLE);
    GPIO_SetBits(GPIOC, GPIO_Pin_7);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOC, &GPIO_InitStructure);
#endif

//	PIOC->D8_SYS_CFG = 0;//halt
	PIOC->D8_SYS_CFG = RB_MST_RESET | RB_MST_IO_EN0;	// reset PIOC & enable IO0

	memcpy( (uint8_t *)(PIOC_SRAM_BASE), PIOC_1W_CODE, sizeof( PIOC_1W_CODE ) );	// load code for PIOC

#if defined SYSCLK_FREQ_24MHz_HSI
	*(uint32_t)(PIOC_SRAM_BASE+PIOC_FREQ_CFG) = 0x00300030;	// set if Fsys=24MHz, default Fsys=48MHz
#else	// default is 48MHz

#endif

//    NVIC_EnableIRQ(PIOC_IRQn);//enable interrupt
//    NVIC_SetPriority(PIOC_IRQn,0xf0);
}

/*********************************************************************
 * @fn      RGB1W_SendSFR
 *
 * @brief   SFR mode for 1~32 bytes data.
 *
 * @param   total_bytes - total data number(byte).
 *          p_source_addr - data.
 *
 * @return  none
 */
void RGB1W_SendSFR( uint16_t total_bytes, uint8_t *p_source_addr ) {//SFR mode for 1~32 bytes data
// p_source_addr: point source data buffer start address, set NULL if copy into PIOC buffer already
	if ( total_bytes > RGB1W_SFR_SIZE ) return;
	PIOC->D8_SYS_CFG = RB_MST_RESET | RB_MST_IO_EN0;//clear&halt PIOC
	PIOC->D8_SYS_CFG = RB_MST_CLK_GATE | RB_MST_IO_EN0;//run PIOC before write SFR
	if ( p_source_addr ) memcpy( RGB1W_SFR_ADDR, p_source_addr, total_bytes );//copy source data to RGB1W SFR, @PIOC run
	RGB1W_COMMAND = (uint8_t)total_bytes;// PIOC start send
}

/*********************************************************************
 * @fn      RGB1W_SendRAM
 *
 * @brief   RAM mode for 1~3072 bytes data.
 *
 * @param   total_bytes - total data number(byte).
 *          p_source_addr - data.
 *
 * @return  none
 */
void RGB1W_SendRAM( uint16_t total_bytes, uint8_t *p_source_addr ) {//RAM mode for 1~3072 bytes data
// p_source_addr: point source data buffer start address, set NULL if copy into PIOC buffer already
	if ( total_bytes > RGB1W_RAM_SIZE ) return;
	PIOC->D8_SYS_CFG = RB_MST_RESET | RB_MST_IO_EN0;//clear&halt PIOC
	if ( p_source_addr ) memcpy( RGB1W_RAM_ADDR, p_source_addr, total_bytes );//copy source data to PIOC SRAM, @PIOC halt
	PIOC->D8_SYS_CFG = RB_MST_CLK_GATE | RB_MST_IO_EN0;//run PIOC after load data in SRAM
	PIOC->D16_DATA_REG0_1 = total_bytes;// data size

#if defined SYSCLK_FREQ_24MHz_HSI
	RGB1W_COMMAND = RGB1W_CYC_24M | RGB1W_CMD_RAM;// set bit cycle and PIOC start send
#else	// default is 48MHz
	RGB1W_COMMAND = RGB1W_CYC_48M | RGB1W_CMD_RAM;// set bit cycle and PIOC start send
#endif

}

/*********************************************************************
 * @fn      RGB1W_SendSFR_Wait
 *
 * @brief   SFR mode for 1~3072 bytes data wait PIOC operate finish.
 *
 * @param   total_bytes - total data number(byte).
 *          p_source_addr - data.
 *
 * @return  none
 */
uint8_t RGB1W_SendSFR_Wait( uint16_t total_bytes, uint8_t *p_source_addr ) {//SFR mode for 1~32 bytes data
// p_source_addr: point source data buffer start address, set NULL if copy into PIOC buffer already
	if ( total_bytes == 0 || total_bytes > RGB1W_SFR_SIZE ) return( RGB1W_ERR_PARA );
	RGB1W_SendSFR( total_bytes, p_source_addr );
	while ( ( PIOC->D8_SYS_CFG & RB_INT_REQ ) == 0 );//wait, PIOC request interrupt after finish
	return( PIOC->D8_CTRL_RD );//auto remove interrupt request after reading
}

/*********************************************************************
 * @fn      RGB1W_SendRAM_Wait
 *
 * @brief   RAM mode for 1~3072 bytes data wait PIOC operate finish.
 *
 * @param   total_bytes - total data number(byte).
 *          p_source_addr - data.
 *
 * @return  none
 */
uint8_t RGB1W_SendRAM_Wait( uint16_t total_bytes, uint8_t *p_source_addr ) {//RAM mode for 1~3072 bytes data
// p_source_addr: point source data buffer start address, set NULL if copy into PIOC buffer already
	if ( total_bytes == 0 || total_bytes > RGB1W_RAM_SIZE ) return( RGB1W_ERR_PARA );
	RGB1W_SendRAM( total_bytes, p_source_addr );
	while ( ( PIOC->D8_SYS_CFG & RB_INT_REQ ) == 0 );//wait, PIOC request interrupt after finish
	return( PIOC->D8_CTRL_RD );//auto remove interrupt request after reading
}

/*********************************************************************
 * @fn      RGB1W_Halt
 *
 * @brief   halt/sleep PIOC .
 *
 * @return  none
 */
void RGB1W_Halt( void ) {//halt/sleep PIOC
	PIOC->D8_SYS_CFG &= ~ RB_MST_CLK_GATE;
}

